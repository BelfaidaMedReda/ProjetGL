// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

    float _power(float base, int exp) {
        float res = 1;
        int i = 0;

        while (i < exp) {
            res = res*base;
            i = i + 1;
        }

        if (exp < 0) {
            res = 1/res;
        }

        return res;
    }

    float _factorial(int n) {
        float res = 1;
        int i = 1;

        while (i <= n) {
            res = res*i;
            i = i + 1;
        }

        return res;
    }

    float _factOdd(int n) {
        float res = 1;
        int i = 1;

        while (i <= n) {
            res = res * (2*i - 1);
            i = i + 1;
        }

        return res;
    }

    float _factEven(int n) {
        float res = 1;
        int i = 1;

        while (i <= n) {
            res = res * (2*i);
            i = i + 1;
        }

        return res;
    }


    float _sqrt(float x) {
        if (x < 0) {
            return -1; // Return -1 for invalid input (negative number)
        }
        // Improved guesses for sqrt based on the range of x
        float guess;
        if (x >= 0.5 and x <= 1) {              // For values close to 1
            guess = 0.5 * x;
        } else if (x < 2.1 and x > 1) {       // For small positive values
            guess = 1.4;
        } else if (x < 0.5) {                    // General case for intermediate values
            guess = x;
        } else {                                // For large values
            guess = x / 2;
        }

        float epsilon = 0.00001; // Precision threshold
        int maxIterations = 20;
        int iterations = 0;

        while (iterations < maxIterations) {
            float newGuess = (guess + x / guess) / 2;
            if (_abs(newGuess - guess) < epsilon) {
                break;
            }
            guess = newGuess;
            iterations = iterations + 1;
        }

        return guess;
    }

    float _abs(float x) {
        if (x < 0) {
            return -x;
        } else {
            return x;
        }
    }

    float readjustAngle(float a) { //  readjusts the angle to be between -π and π
        float pi = 3.14159265358979323846264;
        float twoPi = 6.283185307179586476925286; // 2π

        while (a < -pi) {
            a = a + twoPi;
        }
        while (a > pi) {
            a = a - twoPi;
        }

        return a;
    }

    float sin(float f) {
        f = _readjustAngle(f);
        float sum = f;
        float term;
        int n = 1;
        int nbTerms = 10;

        if (f > 2.356194490192345) {  //  for f > 3π/4, use sin(f) = -sin(f - π)
            
            float res = -sin(f - 3.14159265358979323846264);
            return res;

        } else if(f > 0.78539816339744830961 and f < 2.356194490192345) {  //  for pi/4 < f < 3π/4, use sin(f) = cos(f - pi/2)

            float res = cos(f - 1.570796326794896619231321691639);
            return res;
            
        } else if (f >= 0 and f <= 0.78539816339744830961566084581988) {  //  for 0 <= f <= π/4, use Taylor Series centered in 0  
            
            while (n <= nbTerms) {
            term = _power(f, 2*n + 1) / _factorial(2*n + 1);
            if (n%2 == 1) {
                sum = sum - term;
            } else {
                sum = sum + term;
            }
            n = n + 1;
            }
            return sum;

        } else if (f < -2.356194490192345) {  //  for f < -3π/4, use sin(f) = -sin(f + π)
            
            float res = -sin(f + 3.14159265358979323846264);
            return res;

        } else if(f < -0.78539816339744830961 and f > -2.356194490192345) {  //  for -pi/4 > f > -3π/4, use sin(f) = -cos(f + pi/2)

            float res = -cos(f + 1.570796326794896619231321691639);
            return res;
            
        } else if (f < 0 and f >= -0.78539816339744830961566084581988) {  //  for 0 > f >= -π/4, sin(f) = -sin(-f)
            
            float res = -sin(-f);
            return res;

        }

        
    }

    float cos(float f) {
        f = _readjustAngle(f);
        float sum = 1;
        float term;
        int n = 1;
        int nbTerms = 10;


        if (f > 2.356194490192345) {  //  for f > 3π/4, use cos(f) = -cos(f - π)
            
            float res = -cos(f - 3.14159265358979323846264);
            return res;

        } else if(f > 0.78539816339744830961 and f < 2.356194490192345) {  //  for pi/4 < f < 3π/4, use cos(f) = -sin(f - pi/2)

            float res = -sin(f - 1.570796326794896619231321691639);
            return res;
            
        } else if (f >= 0 and f <= 0.78539816339744830961566084581988) {  //  for 0 <= f <= π/4, use Taylor Series centered in 0  
            
            while (n <= nbTerms) {
                term = _power(f, 2*n) / _factorial(2*n);
                if (n%2 == 1) {
                    sum = sum - term;
                } else {
                    sum = sum + term;
                }
                n = n + 1;
            }
            return sum;

        } else if (f < -2.356194490192345) {  //  for f < -3π/4, use cos(f) = -cos(f + π)
            
            float res = -cos(f + 3.14159265358979323846264);
            return res;

        } else if(f < -0.78539816339744830961 and f > -2.356194490192345) {  //  for -pi/4 > f > -3π/4, use cos(f) = sin(f + pi/2)

            float res = sin(f + 1.570796326794896619231321691639);
            return res;
            
        } else if (f < 0 and f >= -0.78539816339744830961566084581988) {  //  for 0 > f >= -π/4, cos(f) = cos(-f)
            
            float res = -cos(-f);
            return res;

        }
        
    }

    float asin(float f) {

        if (f > 1 or f < -1) {
            return NULL; // not defined, fix NULL
        } else {
            
            if (f > -0.6 and f < 0.6) {   //  for small values of f, use Taylor series
                if (f < 0) {
                    float sum = -1*f;
                    float term;
                    int n = 1;
                    int nbTerms = 10;

                    while (n <= nbTerms) {  //  controls the precision
                        term = _power(f, 2*n + 1);
                        term = (_factOdd(n)/_factEven(n))*(term/(2*n + 1));
                        sum = sum + term;
                        n = n + 1;
                    }

                    return -1*sum;
                }

                float sum = f;
                float term;
                int n = 1;
                int nbTerms = 10;

                while (n <= nbTerms) {  //  controls the precision
                    term = _power(f, 2*n + 1);
                    term = (_factOdd(n)/_factEven(n))*(term/(2*n + 1));
                    sum = sum + term;
                    n = n + 1;
                }
                
                return sum;

            } else {   //  for large values of f, use the polynomial approximation
                if (f < 0) {   // asin(-f) = -asin(f)
                    
                    float a0 = 1.5707288;
                    float a1 = -0.2121144;
                    float a2 = 0.0742610;
                    float a3 = -0.0187293;
                    float x = -1*f;

                    
                    float sqrtValue = sqrt(1 - x);

                    
                    float poly = a0 + a1 * x + a2 * power(x, 2) + a3 * power(x, 3);

                    return -1*(1.570796326794896619231321691639 - sqrtValue * poly); // π/2 - sqrt(1 - f) * polynomial

                } else {
                    
                    float a0 = 1.5707288;
                    float a1 = -0.2121144;
                    float a2 = 0.0742610;
                    float a3 = -0.0187293;

                    
                    float sqrtValue = sqrt(1 - f);

                    
                    float poly = a0 + a1 * f + a2 * power(f, 2) + a3 * power(f, 3);

                    return (1.570796326794896619231321691639 - sqrtValue * poly); // π/2 - sqrt(1 - f) * polynomial
                }    
            }
        }
    }


    float atan(float f) {
        if (f > 0){
            if (f < 0.75){
                float sum = x; // First term in the series
                float term;
                int n = 1;
                int nbTerms = 10; // Number of terms to control precision

                while (n <= nbTerms) {
                    term = power(x, 2 * n + 1) / (2 * n + 1);
                    if (n % 2 == 1) {
                        sum = sum - term; // Subtract for odd terms
                    } else {
                        sum = sum + term; // Add for even terms
                    }
                    n = n + 1;
                }

                return sum;

            } else if (f < 3){

                return asin(_sqrt(_power(f, 2) / (_power(f, 2) + 1)));

            } else if (f >= 3){

                float sum = 1.5707963; // π/2
                float term;
                int n = 0;
                int nbTerms = 10; // Number of terms to control precision

                while (n < nbTerms) {
                    int denominator = 2 * n + 1;
                    term = 1 / (denominator * power(x, denominator));

                    if (n % 2 == 0) {
                        sum = sum - term; // Subtract for even terms
                    } else {
                        sum = sum + term; // Add for odd terms
                    }

                    n = n + 1;
                }

                return sum;
            }
        } else if (f == 0){
            
            return 0;

        } else {

            return -1*atan(-1*f);

        }
    
    }
    float ulp(float f) {
        println("ulp(f) not yet implemented");
    }
}


// End of Deca Math library
